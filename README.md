Задание: Напишите функцию для подсчета количества листьев в бинарном дереве.
 
 ПОДРОБНОЕ ОПИСАНИЕ АЛГОРИТМА

1. Базовый случай: Если текущий узел равен NULL, возвращаем 0

NULL (в C++/Java) или None (в Python) - это специальное значение, означающее "ничего" или "отсутствие узла"
Когда мы доходим до NULL, это означает, что мы вышли за границы дерева или достигли места, где должен быть узел, но его нет
Почему возвращаем 0?

Потому что "ничего" не может быть листом
Это условие остановки рекурсии - предотвращает бесконечные вызовы
Пример: если у узла есть только левый потомок, а правого нет, то при проверке правого потомка мы получим NULL

if root is None:
    return 0  # Нет узла - нет листа

2. Проверка на лист: Если у узла нет левого И правого потомка, возвращаем 1

Лист - узел, который является "конечной точкой" в дереве, у него нет детей - ни слева, ни справа.
В бинарном дереве это "листья" - конечные элементы

Логика условия:

left is None - левого потомка нет
right is None - правого потомка нет
AND - должны выполняться ОБА условия одновременно

Почему возвращаем 1?

Потому что нашли один лист
Каждый лист увеличивает общий счетчик на 1

if root.left is None and root.right is None:
    return 1  # Нашли один лист!

3. Рекурсивный вызов: Иначе рекурсивно подсчитываем листья в левом и правом поддеревьях

Что происходит, когда узел НЕ лист?

Узел имеет хотя бы одного потомка (левого и/или правого)
Значит, нам нужно исследовать его "детей"

Как это работает:

count_leaves(root.left) - "спускаемся" в левое поддерево и считаем листья там
count_leaves(root.right) - "спускаемся" в правое поддерево и считаем листья там
return ... + ... - складываем результаты от обоих поддеревьев

(листья слева) return count_leaves(root.left) + count_leaves(root.right) (листья справа)


ВРЕМЕННАЯ СЛОЖНОСТЬ

Временная сложность: O(n)

Объяснение:

Алгоритм посещает каждый узел ровно один раз
Для каждого узла выполняются константные операции (проверки условий)
Если в дереве n узлов, алгоритм сделает примерно n операций
Математическое объяснение:

Время работы: T(n) = O(1) + T(левый_подъязык) + T(правый_подъязык)
В худшем случае (вырожденное дерево): T(n) = O(n)
В лучшем случае: тоже O(n) - все равно нужно посетить все узлы

Контрольный вопрос: 

Мемоизация — это техника оптимизации, которая сохраняет результаты дорогостоящих вызовов функций и возвращает кэшированный результат при повторных вызовах с теми же входными данными.

Как помогает в рекурсии:

Устраняет повторные вычисления — вместо многократного расчета одинаковых значений используется кэш

Снижает временную сложность — например, в Фибоначчи с O(2ⁿ) до O(n)

Экономит вычислительные ресурсы — trade-off: память vs время процессора
